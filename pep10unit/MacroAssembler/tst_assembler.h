#ifndef TST_ASSEMBLER_H
#define TST_ASSEMBLER_H

#include <QTest>
#include "macromodules.h"

class MacroRegistry;
class MacroPreprocessor;
class MacroAssembler;
struct ModuleAssemblyGraph;
class AssemblerTest : public QObject
{
    Q_OBJECT
public:
    AssemblerTest();
    ~AssemblerTest() override;

private slots:
    void initTestCase();
    void cleanupTestCase();

    // Test cases where an otherwise valid program forgets a .END.
    void case_missingEnd_data();
    void case_missingEnd();

    // Test that true syntax errors are propogated to the end user.
    void case_syntaxError_data();
    void case_syntaxError();

    // Test cases for tokens generated by syntax errors.
    void case_unexpectedToken_data();
    void case_unexpectedToken();

    // Test cases where an EOL is encountered too early.
    void case_unexpectedEOL_data();
    void case_unexpectedEOL();

    // Test cases where something other than a comment is detected after a newline.
    // However, this should be impossible to hit, since lines always have a \n appened to them.
    //void case_expectNewlineCommnet_data();
    //void case_expectNewlineCommnet();

    // Test cases where a symbol is declared unexpctedly.
    void case_unexpectedSymbolDeclaration_data();
    void case_unexpectedSymbolDeclaration();

    // Test cases with non-existant mnemonics e.g. "YETI".
    void case_invalidMnemonic_data();
    void case_invalidMnemonic();

    // Test cases for dot commands that may only occur in operating system.
    void case_onlyInOS_data();
    void case_onlyInOS();

    // Test cases for invalid dot commands e.g. "YETI".
    void case_invalidDotCommand_data();
    void case_invalidDotCommand();

    // Test cases where a symbol is declared to be too long.
    void case_symbolTooLong_data();
    void case_symbolTooLong();

    // Test cases where an instruction that requires an addressing mode
    // is not given one.
    void case_badAddrMode_data();
    void case_badAddrMode();

    /*
     * Since the preprocessor aggressively catches errors concerning macro names
     * and argument counts, these tests have been commented out, and their
     * implementations removed. While our macro assembler is defensive against
     * this family of errors, it is impossible for it to occur in practice.
     */
    // Test cases where the invoked macro does not exist.
    //void case_noSuchMacro_data();
    //void case_noSuchMacro();
    // Test cases where the invoked macro is given the wrong number of arguments.
    //void case_badMacroArgCount_data();
    //void case_badMacroArgCount();

    // Test cases where something is wrong with the macro argument list,
    // but the macro does exist, and has the correct number of arguments.
    void case_badMacroSub_data();
    void case_badMacroSub();

    // Test cases where a nonunary instruction is not given an operand specifier.
    void case_expectOperand_data();
    void case_expectOperand();

    // Test cases where a value is incapable of being represented by a byte.
    void case_byteOutOfRange_data();
    void case_byteOutOfRange();

    // Test cases where a value is incapable of being represented by a word.
    void case_wordOutOfRange_data();
    void case_wordOutOfRange();

    /*
     * Begin tests for dot commands.
     * Unlike instructions, the operand type for each dot command is limited,
     * and each test checks all operand types with each command.
     */
    // Test cases where .ADDRSS is given a bad argument.
    void case_badAddrssArg_data();
    void case_badAddrssArg();

    // Test cases where .ALIGN is given a bad argument.
    void case_badAlignArg_data();
    void case_badAlignArg();

    // Test cases where .ASCII is given a bad argument.
    void case_badAsciiArg_data();
    void case_badAsciiArg();

    // Test cases where .BLOCK is given a bad argument.
    void case_badBlockArg_data();
    void case_badBlockArg();

    // Test cases where .BURN is given a bad argument.
    void case_badBurnArg_data();
    void case_badBurnArg();

    // Test cases where .BYTE is given a bad argument.
    void case_badByteArg_data();
    void case_badByteArg();

    // Test cases where .END is not alone or followed by a comment.
    void case_badEnd_data();
    void case_badEnd();

    // Test cases where .EQUATE does not define a symbol.
    void case_noSymbolEquate_data();
    void case_noSymbolEquate();

    // Test cases where .EQUATE is given a bad argument.
    void case_badEquateArg_data();
    void case_badEquateArg();

    // Test cases where .EXPORT attempts to define a symbol.
    void case_symbolExport_data();
    void case_symbolExport();

    // Test cases where .EXPORT is given a bad argument,
    // or it is used in a non-operating system module.
    // Validation of .EXPORT injecting symbols into user programs
    // requires validation of the linker, so see dedicated
    // tests in tst_userosintegration.h
    void case_badExportArg_data();
    void case_badExportArg();

    // Test cases where .SCALL defines a symbol
    void case_noSymbolScall_data();
    void case_noSymbolScall();

    // Test cases where .SCALL is given a bad argument.
    void case_badScallArg_data();
    void case_badScallArg();

    // Test cases where .USCALL defines a symbol
    void case_noSymbolUscall_data();
    void case_noSymbolUscall();

    // Test cases where .USCALL is given a bad argument.
    void case_badUscallArg_data();
    void case_badUscallArg();

    // Test cases where .WORD is given a bad argument.
    void case_badWordArg_data();
    void case_badWordArg();

private:
    QSharedPointer<MacroRegistry> registry;
    QSharedPointer<MacroPreprocessor> preprocessor;
    QSharedPointer<MacroAssembler> assembler;
    void preprocess(ModuleAssemblyGraph& graph, ModuleType moduleType);
    void execute();
};

#endif // TST_ASSEMBLER_H
