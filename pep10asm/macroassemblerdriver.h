#ifndef MACROASSEMBLERDRIVE_H
#define MACROASSEMBLERDRIVE_H

#include <QString>
#include <QtCore>
#include <QObject>

#include "asmprogram.h"
#include "ngraph.h"
#include "macromodules.h"
#include "macropreprocessor.h"
#include "symboltable.h"

class MacroTokenizer;
class MacroRegistry;
class MacroAssembler;
class MacroLinker;
/*
 * The MacroAssemblerDriver coordinates the various phases of assembly in the macro assembler.
 * They are as follows
 *
 * Preprocess:
 *  The preprocessing phase of the assembler detects any macro invocations, and validates
 *  that the macro syntax and semantics are correct.
 *
 * Build:
 *  The resulting AssemblyGraph is converted into a list of codelines.
 *  Just as in Pep9, we use a tokenizer to assemble our programs.
 *  The assembler adapts which methods are available based on the type of the module being parsed.
 *
 * Link:
 *  External symbols (e.g. symbols in the operating system that had a .EXPORT) are pulled into
 *  all modules symbol tables.
 *  Checks for multiply defined / undefined symbols in module table.
 *  The address of each code line is calculated.
 *
 *  (Copying module instances)
 *  Each Macro code line contains a pointer to a module instance, and each instance contains
 *  lines of code.  After the build step, multiple macro lines may point to the same module
 *  instance object. This means there is a many-to-one mapping between code lines in the
 *  user program and code lines in macro instances. This many to one mapping causes issues
 *  when instructions generate diffrent object code based on their address, like ALIGN.
 *  During the link step, each macro line makes a deep copy of the module instance that
 *  it points to, re-establishing the one-to-one mapping between code lines.
 *
 *  This introduces several additional levels of complexity inside of the linker,
 *  so why not just assemble each macro invocation as it's own module instance?
 *  Well, with my unit tests (which are more deeply nested than most user code)
 *  it was a difference of assembling 70+ module instances versus 15.
 *  Considering our new assembly process is time intensive, and we reassemble the
 *  program every time the simulation is run, this optimization provides a
 *  significant performance boost.
 *
 *  Other possible solutions included making AsmCode lines contain an offset and
 *  a base address, but this failed to correct for the strange behavior of ALIGN.
 *
 * Annotate:
 *  In Pep9, the detection of trace tags was "baked in" to the build step.
 *  By having a separate step where stack trace symbol information is collected,
 *  we can improve the code quality used in this section. This code was
 *  becoming difficult to maintain, and has lead to several open issues.
 *
 * Validate:
 *  After we have finished assembling, make sure that the final program makes sense.
 *  e.g. Is the program length longer than 2^16 bytes? If so, it will fail here.
 *  After validation is complete, we can construct an executable assembly program,
 *  and finally return to the user.
 *
 * Code Generation:
 *  This step is not performed by the assembler, but by the MacroAsmProgram returned by the assembler.
 *  This object contains all the information about a particular assembly invocation, as is capable of
 *  generating executable object code without outside help.
 * All errors generated by nested modules MUST be propogated to the root module, preferably on
 * the macro invocation that started the path to the error.
 */
class MacroAssemblerDriver
{
public:
    MacroAssemblerDriver(QSharedPointer<MacroRegistry>  registry);
    ~MacroAssemblerDriver();
    QSharedPointer<AsmProgram> assembleUserProgram(QString input, QSharedPointer<const SymbolTable> osSymbol);
    QSharedPointer<AsmProgram> assembleOperatingSystem(QString input);
    bool validateMacro(QString input);

private:
    // All instances of a macro will include the same macros, so
    // it is safe to use a ModulePrototype. This means an expression of the form %DECO$1 is
    // an invalid macro, and must be flagged as such.
    // Detect any macros used in the module.
    // Return true if compilation may continue, or false if there were errors.
    bool preprocess();


    // Use module instances, because macros may have different arguments. If two instances
    // share the same macro and arguments, they are the same macro.
    // Replace macro symbols $1 $2 $3 before they reach the normal assembly function
    // Generate the code line objects, detect symbols, but do not assign addresses or sizes.
    bool assembleProgram();
    // Calculate real address of each code line,
    bool link();
    // Annotate functions that modify the stack.
    void annotate(ModuleInstance& module);
    // Perform any last-minute sanity checks before returning AssemblyProgram.
    // For example, that the program object code can fit in main memory.
    void validate(ModuleInstance& module);

    QSharedPointer<MacroRegistry> registry;
    MacroPreprocessor *processor;
    MacroAssembler *assembler;
    MacroLinker *linker;
    ModuleAssemblyGraph graph;

};

#endif // MACROASSEMBLERDRIVE_H
